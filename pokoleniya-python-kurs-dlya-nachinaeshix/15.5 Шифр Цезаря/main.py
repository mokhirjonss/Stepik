# 15.5 Шифр Цезаря

# Шифр Цезаря

# Шифр Цезаря (шифр сдвига) — один из самых простых и наиболее широко известных методов шифрования.
# Шифр Цезаря — это вид шифра подстановки, в котором каждый символ в открытом тексте заменяется символом,
# находящимся на некотором постоянном числе позиций левее или правее него в алфавите.

# Шифр подстановки — метод шифрования с заменой элементов исходного открытого текста другими,
# в соответствии с неким правилом.

# Например, в шифре со сдвигом вправо на 3 позиции символ A заменяется символом D, символ B — символом E, и так далее,
# до символа Z, заменяемого символом C.

# Шифр назван в честь римского полководца Гая Юлия Цезаря, использовавшего его для секретной переписки
# со своими генералами.

# Шифр Цезаря легко взламывается и не имеет почти никакого практического применения.

# Математическая модель

# Если сопоставить каждый символ алфавита с его порядковым номером (нумеруя с 0), то шифрование и дешифрование можно
# выразить формулами модульной арифметики:
# y = (x + k) mod n
# x = (y - k) mod n,
# где x — символ открытого текста, y — символ шифрованного текста, n — мощность
# алфавита (количество символов), а k — ключ.

# Под операцией mod подразумевается операция нахождения остатка. В языке Python для нахождения остатка от деления двух
# чисел, мы используем оператор %.

# Пример

# Шифрование с использованием ключа k=3. Буква «Е» «сдвигается» на три буквы вперед и становится буквой «З».
# Твердый знак, перемещенный на три буквы
# вперед, становится буквой «Э», буква «Я», перемещенная на три буквы вперед, становится буквой «В», и так далее:

# Исходный алфавит: А Б В Г Д Е Ё Ж З И Й К Л М Н О П Р С Т У Ф Х Ц Ч Ш Щ Ъ Ы Ь Э Ю Я
# Шифрованный:      Г Д Е Ё Ж З И Й К Л М Н О П Р С Т У Ф Х Ц Ч Ш Щ Ъ Ы Ь Э Ю Я А Б В

# Оригинальный текст:
# Съешь же ещё этих мягких французских булок, да выпей чаю.

# Шифрованный текст:
# Фэзыя йз зьи ахлш пвёнлш чугрщцкфнлш дцосн, жг еютзм ъгб.

# Взлом шифра

# Шифр Цезаря может быть легко взломан даже в случае, когда взломщик знает только зашифрованный текст.
# Можно рассмотреть две ситуации:

# Взломщик знает (или предполагает), что использовался простой шифр подстановки, но не знает, что это — схема Цезаря.
# Взломщик знает, что использовался шифр Цезаря, но не знает значение сдвига.

# В первом случае шифр может быть взломан с применением метода частотного анализа. Используя этот метод, взломщик,
# вероятно, быстро заметит регулярность в решении и поймет, что используемый шифр — шифр Цезаря.

# Во втором случае взлом шифра еще более прост. Существует не так много вариантов значений сдвига
# ( 26 для английского языка, 32 для русского языка), все они могут быть проверены перебором.

# Примечания

# Примечание 1. Используемое преобразование в шифре Цезаря обычно обозначают как ROT N, где N — сдвиг, ROT — сокращение
# от слова ROTATE, в данном случае «циклический сдвиг». Например, обозначение ROT 2 обозначает сдвиг на 2 позиции,
# то есть, «а» превращается в «в», «б» в «г», и так далее, и в конце «ю» превращается в «а» а «я» — в «б».

# Примечание 2. Число разных преобразований зависит от длины алфавита:
# для русского языка возможно 32 разных преобразования (преобразования ROT 0 и ROT 33 сохраняют исходный текст,
# а дальше начинаются уже повторения);
# для английского языка возможны 25 разных преобразований (преобразования ROT 0 и ROT 26 сохраняют исходный текст,
# а дальше начинаются уже повторения).

# Примечание 3. Неалфавитные символы — знаки препинания, пробелы, цифры — не меняются.

# Примечание 4. Естественным развитием шифра Цезаря стал шифр Виженера.

# Как вы думаете, улучшает ли многократное шифрование стойкость алгоритма Цезаря?
# Многократное шифрование никак не улучшает стойкость, так как применение шифров со сдвигом n и k эквивалентно
# применению шифра со сдвигом n + k.

# Какой из алгоритмов ROT N можно отменить, применив тот же алгоритм? (Одни и те же действия могут быть использованы
# для кодирования и декодирования).

# Примечание. Используется английский алфавит в котором 26 букв.
# ROT 13 является обратимым алгоритмом, то есть отменить ROT 13 можно, применив тот же алгоритм; одни и те же действия
# могут быть использованы для кодирования и декодирования. Другими словами, применив алгоритм ROT 13 к уже ROT 13
# зашифрованному тексту, получим первоначальный текст.

# Шифр Цезаря

# Описание проекта: требуется написать программу, способную шифровать и дешифровать текст в соответствии с алгоритмом
# Цезаря. Она должна запрашивать у пользователя следующие данные:

# направление: шифрование или дешифрование;
# язык алфавита: русский или английский;
# шаг сдвига (со сдвигом вправо).

# Примечание 1. Считайте, что в русском языке 32 буквы (буква ё отсутствует).
# Примечание 2. Неалфавитные символы — знаки препинания, пробелы, цифры — не меняются.
# Примечание 3. Сохраните регистр символов. Например, текст: "Умом Россию не понять" при сдвиге на одну позицию вправо
# будет преобразован в: "Фнпн Спттйя ож рпоауэ".

# Составляющие проекта:
# Целые числа (тип int);
# Модульная арифметика;
# Переменные;
# Ввод / вывод данных (функции input() и print());
# Условный оператор (if/elif/else);
# Цикл for/while;
# Строковые методы.

# Зашифруйте текст "Блажен, кто верует, тепло ему на свете!" алгоритмом Цезаря с сдвигом вправо на 10 символов.

# Примечание. Считайте, что русский алфавит состоит из 32 букв (буква ё отсутствует).
# Лхкрпч, фьш мпъэпь, ьпщхш пцэ чк ымпьп!

# Зашифруйте текст "To be, or not to be, that is the question!" алгоритмом Цезаря с сдвигом вправо на 17 символов.
s="To be, or not to be, that is the question!"
s2=''
for i in s:
    d=ord(i)
    if 65<=d<=90:
        d +=17
        if d>=91:
            d -=26
        s2 +=chr(d)
    elif 97<=d<=122:
        d +=17
        if d>=123:
            d -=26
        s2 +=chr(d)
    elif d<65 or 91<=d<=96 or d>122:
        s2 +=i
print(s2)
# Kf sv, fi efk kf sv, kyrk zj kyv hlvjkzfe!

# Текст "Шсъцхр щмчжмщ йшм, нмтзж йшм лхшщзщг." был получен в результате шифрования алгоритмом Цезаря с сдвигом вправо
# на 7 символов. Расшифруйте данный текст.

# Примечание. Считайте, что русский алфавит состоит из 32 букв (буква ё отсутствует).
# Скупой теряет все, желая все достать.

# Текст "Sgd fqzrr hr zkvzxr fqddmdq nm sgd nsgdq rhcd ne sgd edmbd." был получен в результате шифрования алгоритмом
# Цезаря со сдвигом вправо на 25 символов. Расшифруйте данный текст.
# The grass is always greener on the other side of the fence.

# Текст "Hawnj pk swhg xabkna ukq nqj." был получен в результате шифрования алгоритмом Цезаря с сдвигом вправо на n
# символов. Расшифруйте данный текст.
# Примечание. Считайте, что n∈[0;25].
s = "Hawnj pk swhg xabkna ukq nqj."

d = 'abcdefghijklmnopqrstuvwxyz'

for k in range(25):
    b = ''
    for i in range(len(s)):
        if not s[i].isalpha():
            b += s[i]
        else:
            if s[i].isupper():
                b += (d[d.find(s[i].lower())-k]).upper()
            else:
                b += d[d.find(s[i].lower())-k]
    print(b)

# Аве, Цезарь 🌶️
# На вход программе подается строка текста на английском языке, в которой нужно зашифровать все слова.
# Каждое слово строки следует зашифровать с помощью шифра Цезаря (циклического сдвига на длину этого слова).
# Строчные буквы при этом остаются строчными, а прописные – прописными. Гарантируется, что между различными словами
# присутствует один пробел.

# Формат входных данных
# На вход программе подается строка текста на английском языке.

# Формат выходных данных
# Программа должна вывести зашифрованный текст в соответствии с условием задачи.

# Примечание. Символы, не являющиеся английскими буквами, не изменяются.

import string

# Очищаем слово от символов
def removed_chars(s):
    del_chars = ',.!#$:()"~@%;?'
    return s.translate(str.maketrans('', '', del_chars))

def encrypt_word(word):
    """
    Функция шифрует слово с помощью шифра Цезаря с циклическим сдвигом на длину слова.
    """
    word_clear = removed_chars(word) # Очищаем слово от символов
    shift = len(word_clear) # Длина слова без символов
    lower_alphabet = string.ascii_lowercase # Получаем алфавит в нижнем регистре
    upper_alphabet = string.ascii_uppercase # Получаем алавит в верхнем регистре
    encrypted = "" # Создаем пустой список в который будем добавлять шифрованные буквы
    for char in word:
        if char in lower_alphabet:
            # Шифруем строчные буквы
            encrypted += lower_alphabet[(lower_alphabet.index(char) + shift) % 26]
        elif char in upper_alphabet:
            # Шифруем прописные буквы
            encrypted += upper_alphabet[(upper_alphabet.index(char) + shift) % 26]
        else:
            # Оставляем не буквенные символы как есть
            encrypted += char
    return encrypted

def encrypt_sentence(sentence):
    """
    Функция шифрует все слова в предложении с помощью шифра Цезаря.
    """
    words = sentence.split()
    encrypted_words = []
    for word in words:
        encrypted_word = encrypt_word(word)
        encrypted_words.append(encrypted_word)
    return " ".join(encrypted_words)


# Ввод фразы и вывод шифрованой
sentence = input().strip()
print(encrypt_sentence(sentence))
